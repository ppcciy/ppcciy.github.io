<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/09/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>3种排序算法-归并排序，快速排序，推排序</title>
    <url>/2024/09/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>我的第一篇博客₍˄·͈༝·͈˄*₎◞ ̑̑♡</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>​        常见的排序算法有很多，比如插入排序，希尔排序，选择排序，冒泡排序，归并排序，快速排序，堆排序等等。</p>
<p><img lazyload src="/images/loading.svg" data-src="https://img-blog.csdnimg.cn/4ea956ed6bbe434d826b2d5406b86909.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY2FsbV9H,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="10中排序算法简介"></p>
<h2 id="时间复杂度-空间复杂度"><a href="#时间复杂度-空间复杂度" class="headerlink" title="时间复杂度&amp;空间复杂度"></a>时间复杂度&amp;空间复杂度</h2><p>时间复杂度与空间复杂度的作用是在衡量一个算法的优劣性。</p>
<p>时间复杂度是指执行算法所需时间的增长率，而空间复杂度则是指执行算法所需存储空间的增长率。</p>
<h3 id="一、时间复杂度"><a href="#一、时间复杂度" class="headerlink" title="一、时间复杂度"></a>一、时间复杂度</h3><p>时间复杂度表示算法运行<strong>时间的相对大小</strong>，时间复杂度不是指具体的时间，而是算法的运算次数，是相对于问题规模的相对量。</p>
<p><strong>时间复杂度表示方法 - 大 O 表示法</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">常数阶</span><br><span class="line">时间复杂度为 <span class="built_in">T</span>(n) = <span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">function <span class="built_in">aFun</span>() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!&quot;</span>);      <span class="comment">//  需要执行 1 次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">// 需要执行 1 次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">我们看到总共要执行<span class="number">2</span>次，我们来简化一下，用<span class="number">1</span>取代所有的常量，就变成了<span class="built_in">O</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">时间复杂度为 <span class="built_in">T</span>(n) = <span class="built_in">O</span>(n)</span><br><span class="line">    </span><br><span class="line">function <span class="built_in">bFun</span>(n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(let i = <span class="number">0</span>; i &lt; n; i++)         <span class="comment">// 需要执行 (n + 1) 次</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!&quot;</span>);      <span class="comment">// 需要执行 n 次</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">// 需要执行 1 次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">总共需要执行 <span class="number">2</span>n + <span class="number">2</span>次，简化一下，<span class="built_in">O</span>(n)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">时间复杂度为 <span class="built_in">T</span>(n) = <span class="built_in">O</span>(log2n)</span><br><span class="line"></span><br><span class="line">let i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">   i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码是从 <span class="number">1</span> 开始，每次循环就乘以 <span class="number">2</span>，当大于 n 时，循环结束。</span><br><span class="line">i 的取值就是一个等比数列。</span><br><span class="line"><span class="number">2</span>^<span class="number">0</span> <span class="number">2</span>^<span class="number">1</span> <span class="number">2</span>^<span class="number">2</span> ... <span class="number">2</span>^k ... </span><br><span class="line">我们令<span class="number">2</span>^x = n，求解 x即可</span><br><span class="line">解得 x = log2n 。所以上面代码的时间复杂度为 <span class="built_in">O</span>(log2n)。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h3 id="二、空间复杂度"><a href="#二、空间复杂度" class="headerlink" title="二、空间复杂度"></a>二、空间复杂度</h3><p>空间复杂度表示<strong>算法的存储空间与数据规模之间的增长关系</strong>。</p>
<p>算法的空间复杂度通过计算算法所需的存储空间实现，是对一个算法在运行过程中临时占用存储空间大小的量度。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">空间复杂度为 O（<span class="number">1</span>）</span><br><span class="line">    </span><br><span class="line">	<span class="function">function <span class="title">aFun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   		<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;j&quot;</span> );</span><br><span class="line">		&#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">随着i的变化，所需开辟的内存空间并不会随着i的变化而变化,因为 这 i、j 用的时相同的空间， i 、j各一个，简化一下就是 O（<span class="number">1</span>） </span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">空间复杂度为 O（n）</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">bFun</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">		<span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">			a[i] = i * i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			print out a[i]</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第<span class="number">2</span>行申请了一个空间存储变量 i，但是它是常量阶的，可以忽略。</span><br><span class="line">第<span class="number">3</span>行申请了一个大小为 n 的 <span class="type">int</span> 类型数组</span><br><span class="line">除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 <span class="built_in">O</span>(n)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>









<p>这次分享我给大家带来的是<strong>归并排序</strong>，<strong>快速排序</strong>以及<strong>堆排序</strong>。</p>
<p>PS.<em>推荐2个可视化网站</em></p>
<ul>
<li><p>**Structure Visualization **  <a class="link" href="https://www.cs.usfca.edu/~galles/visualization/">https://www.cs.usfca.edu/~galles/visualization/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p><strong>VisuAlgo</strong>  <a class="link" href="https://visualgo.net/">https://visualgo.net <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<h2 id="1-归并排序（Merge-sort）"><a href="#1-归并排序（Merge-sort）" class="headerlink" title="1.归并排序（Merge sort）"></a>1.归并排序（Merge sort）</h2><h3 id="1-1算法思路"><a href="#1-1算法思路" class="headerlink" title="1.1算法思路"></a>1.1算法思路</h3><p>归并排序采用的是<strong>分治</strong>的思想。它的基本的2个操作，一就是<strong>分</strong>，将序列划分为2个子序列；二是<strong>治</strong>，将2个有序序列合成一个序列。具体操作如下：</p>
<ul>
<li><p>将待排序的序列不断地进行二分，直到每个序列只包含一个元素，这时，可以认为只包含一个元素的子序列是有序序列。</p>
</li>
<li><p>将子序列两两合并，重复这一操作，直到把所有子序列全部为一个序列。（<strong>双指针</strong>）</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" alt="归并排序"></p>
<h3 id="1-2代码实现"><a href="#1-2代码实现" class="headerlink" title="1.2代码实现"></a>1.2代码实现</h3><p><em><strong>确定分界点(下标的mid)-&gt;递归排序-&gt;归并</strong></em></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">	<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">	<span class="built_in">merge_sort</span>(q, mid<span class="number">+1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并</span></span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++]=q[i++];</span><br><span class="line">			<span class="keyword">else</span> tmp[k++]=q[j++];</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=r)   tmp[k++]=q[j++];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">merge_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="1-3效率分析"><a href="#1-3效率分析" class="headerlink" title="1.3效率分析"></a>1.3效率分析</h3><p>**归并排序的时间复杂度为O(N * log2N)**，因为向下递归的复杂度为O(log2N)，然后遍历一遍数组的复杂度为O(N)，所以总的时间复杂度为O(N * log2N)   ，速度仅次于快速排序。</p>
<p>**归并排序的空间复杂度为O(N)**，因为需要创建一个tmp辅助数组用来存归并后的序列。</p>
<h2 id="2-快速排序（Quick-sort）"><a href="#2-快速排序（Quick-sort）" class="headerlink" title="2.快速排序（Quick sort）"></a>2.快速排序（Quick sort）</h2><h3 id="2-1算法思路"><a href="#2-1算法思路" class="headerlink" title="2.1算法思路"></a>2.1算法思路</h3><p>1、首先<strong>确定分界点（具体的数组里的值）</strong>（q[l] , q[(l+r)&#x2F;2] , q[r] , 随机）</p>
<p>2、<strong>调整区间</strong>，将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。</p>
<p>3、<strong>递归处理左右两端</strong>，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p>
<p><img lazyload src="/images/loading.svg" data-src="E:\Desktop\学习\AcWing\快排.gif" alt="img"></p>
<h3 id="2-2代码实现"><a href="#2-2代码实现" class="headerlink" title="2.2代码实现"></a>2.2代码实现</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序(分治 </span></span><br><span class="line"><span class="comment">//确定分界点-&gt;*调整位置*-&gt;递归处理左右两端段 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> <span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> x=q[(l + r) / <span class="number">2</span>],i=l<span class="number">-1</span>,j=r<span class="number">+1</span>;<span class="comment">//先移动再判断</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">		<span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);<span class="comment">//swap交换2个数 </span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,j<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3效率分析"><a href="#2-3效率分析" class="headerlink" title="2.3效率分析"></a>2.3效率分析</h3><p><strong>最好情况</strong>：每次数据元素都能平均的分成两个部分。得到一个完全二叉树。时间复杂度为O(nlogn)。</p>
<p><strong>最坏情况</strong>：在最坏的情况下，这个数仅有右子树或左子树，比较次数为 （n-1）+（n-2) + (n-3) + … +1&#x3D;n*(n-1)&#x2F;2 ,因此时间复杂度为O(n^2)。</p>
<p>快速排序是一种<strong>不稳定</strong>的排序算法，会改变数据元素的相对位置，也是内排序中平均效率最高的排序算法。</p>
<h2 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3.堆排序"></a>3.堆排序</h2><h3 id="3-1堆（Heap）"><a href="#3-1堆（Heap）" class="headerlink" title="3.1堆（Heap）"></a>3.1堆（Heap）</h3><h4 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h4><p>堆是一种叫做<strong>完全二叉树</strong>的数据结构，可以分为大根堆，小根堆，堆排序就是基于这种结构产生的排序算法。</p>
<h4 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h4><p><strong>大根堆</strong>：每个节点的值都大于或等于他的左右孩子节点的值。</p>
<p>逻辑结构：</p>
<p><img lazyload src="/images/loading.svg" data-src="E:\Desktop\学习\AcWing\大根堆" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAb29yaWs=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>存储结构：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>10</td>
<td>8</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>7</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><strong>小根堆</strong>：每个节点的值都小于或等于他的左右孩子节点的值</p>
<p><img lazyload src="/images/loading.svg" data-src="E:\Desktop\学习\AcWing\小根堆" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAb29yaWs=,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>存储结构：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>3</td>
<td>4</td>
<td>6</td>
<td>5</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
</tbody></table>
<p>&#x2F;&#x2F; 父→子  :  i→左孩子：2*i+1;   i→右孩子：2*i+2;</p>
<p>&#x2F;&#x2F; 子→父  : （i-1)&#x2F;2;</p>
<p>&#x2F;&#x2F; i为下标元素</p>
<h3 id="3-2堆排序"><a href="#3-2堆排序" class="headerlink" title="3.2堆排序"></a>3.2堆排序</h3><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>1.首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端。<strong>【构造大根堆】</strong></p>
<p>2.将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1。<strong>【排序】</strong></p>
<p>3.将剩余的n-1个数再构造成大根堆，再将顶端数与n-1位置的数交换，如此反复执行，便能得到有序数组。<strong>【重复】</strong></p>
<p>注意:升序用大根堆，降序就用小根堆(默认为升序)</p>
<p>eg:给定一个数组{4、8、6、2、10}</p>
<p><strong>构造大根堆</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="E:\Desktop\学习\AcWing\堆排序1.png" alt="堆排序1"></p>
<p>图1：首先我们将这个无序的序列里的值按照从上往下，从左到右依次填充到二又树中。</p>
<p>图:2： 我们找到<strong>最后一个非叶子节点</strong>，即元素值为8的节点，<strong>比较</strong>它的左右节点中最大的一个的值，是否比他大，如果大就交换位置。2小于8,而10大于8，则交换8和10的位置。</p>
<p>图3：找到下一个非叶子节点4，用它和它的左右子节点进行比较，发现4小于10,6这2个节点。交换4与10的位置。</p>
<p>图4：此时发现4小于8这个子节点，我们需要进行调整，交换4和8的位置。</p>
<p><strong>第一次交换重构</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="E:\Desktop\学习\AcWing\堆排序2.png" alt="堆排序2"></p>
<p>首先将顶点元素10与末尾元素4交换位置，此时末尾数字为最大值。<strong>排除已经确定的最大元素，将剩下元素重新构建大根堆</strong></p>
<p>此时元素9已经有序，未尾元素则为4。(每调整一次，<strong>调整后的尾部元素在下次调整重构时都不能动</strong>)</p>
<p><strong>第二次交换重构</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="C:\Users\王婧怡\AppData\Roaming\Typora\typora-user-images\image-20240407125225284.png" alt="image-20240407125225284"></p>
<p><strong>第三次交换重构</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="E:\Desktop\学习\AcWing\堆排序4.png" alt="堆排序4"></p>
<p>最终得到有序序列{2,4,6,8,10}</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostreeam&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = arr[start];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * start + <span class="number">1</span>; i &lt;= end; i = i * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; end&amp;&amp; arr[i] &lt; arr[i + <span class="number">1</span>])</span><br><span class="line">			i++;<span class="comment">//保证i一定是左右孩子的最大值</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			arr[start] = arr[i];</span><br><span class="line">			start = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	arr[start] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//建立大根堆，从最后一个非叶子节点开始，依次调整堆。</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(len<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="built_in">HeapAdjust</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = arr[<span class="number">0</span>];</span><br><span class="line">		arr[<span class="number">0</span>] = arr[len - <span class="number">1</span>-i];</span><br><span class="line">		arr[len - <span class="number">1</span> - i] = tmp;</span><br><span class="line">        </span><br><span class="line">		<span class="built_in">HeapAdjust</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>-i- <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">HeapSort</span>(q, n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><ul>
<li><p>堆排序的时间复杂度为O(nlogn)。这是因为建立初始堆需要O(n)的时间，而每次调整堆的操作需要O(logn)的时间，总共需要进行n-1次调整。</p>
</li>
<li><p>堆排序是一种<strong>不稳定</strong>的排序算法。在调整堆的过程中，可能会改变相同元素之间的相对顺序。</p>
</li>
</ul>
]]></content>
  </entry>
</search>
